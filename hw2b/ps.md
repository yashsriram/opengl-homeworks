# Assignment 2b: Programming Interactive 2D Graphics with OpenGL and GLFW

- The goal of this assignment is to give you experience with implementing simple 2D geometric transformations in a vertex shader to allow a user to interactively reposition and resize a single object in a window via the mouse and keyboard. You are asked to use GLFW to manage the user input.

- Note from TA: Looks like the starter code is having issues downloading the dependencies for some students, similar to hw2a. I tweaked the starter code and added it to the same repo as hw2a <https://github.com/LiamTyler/5607-hw2a-starter>. I made the hw2b code as a new "hw2b" branch. Follow the install instructions in the README.md. You can use this as the starter code, or do it from scratch. If you do your own thing though, (and in general) make sure your ZIP submission compiles on lab machines

That accomplishes the following:

- Defines a simple 2D object (a square, formed by two triangles);
- Associates distinct color information with each vertex (to make it easier to see how the object is moving or changing size);
- Opens a window and renders the defined object.

Before getting started with the requirements below, you should verify that you can compile and run the provided code. Then, you should modify your working program to add each of the following functionalities, one by one.  Please ensure after making each modification that your program still works as described.

- Allow the user to scale the model about its centroid and along its intrinsic width or height axes using the arrow keys on the keyboard, such that the left arrow key causes the object to become thinner, the right arrow key causes the object to become fatter, the up arrow causes the object to become taller, and the down arrow causes the object to become more squat. Please note that the behavior described above needs to be maintained after adding the additional functionalities described below.  In other words, after implementing step 2, you should go back and verify that the arrow keys still work to make the figure fatter, shorter, taller, thinner, regardless of its orientation in the image plane.
- Allow the user to rotate the model about its centroid by moving the mouse from side-to-side while the left button is pressed. The object should consistently rotate in a clockwise direction when the mouse is moved to the right, and in a counterclockwise direction when the mouse is moved to the left. To facilitate rotating the object about its centroid, the provided model was defined to have (0, 0) at its center.  Please note that the behavior described above needs to be maintained after adding the additional functionality described below.  In other words, after implementing step 3, you should go back and verify that moving the mouse to the right causes the figure to rotate in a clockwise direction around its centroid, etc.
- Allow the user to translate the model within the display window by moving the mouse while the left button is pressed and the ‘control’ key is down. The direction of motion of the object should be match (as closely as possible) the direction of motion of the mouse and the amount of object motion match (as closely as possible) the amount of mouse movement.  This means that when the user presses ‘control’ and moves the mouse upwards by 10 pixels in the display window, the object should also move upwards by about 10 pixels, as if the mouse were stuck to the surface of the object.  Please note that this behavior should be maintained regardless of the rotational orientation of the object.  In other words, if the object is rotated so that it appears upside down, when the user presses ‘control’ and moves the mouse upwards by 10 pixels in the display window, the object should still move upwards by about 10 pixels, and not downwards or in some other direction. Please note that the mouse coordinates will be ‘flipped’ along the y axis with respect to the world coordinates of your scene, because the origin of the window is defined to be at its upper left corner and y values increase downward from there, while the origin of the coordinate system in which the object is defined will appear at the center of the viewing window, with y coordinates increasing upwards.  There is no similar problem with the x coordinates because they will increase towards the right in each case. You can enforce that the object remains within the display window by disallowing translation operations that would move the centroid outside of the range (–1 .. 1).  If for some reason using the control key doesn’t work on your computer, you can feel free to designate an alternative, such as the ‘alt’ key or the caps lock key; please just be sure to make this clear in a Readme file to avoid misunderstanding when your assignment is tested during grading.

For 5% extra credit:
- Allow the user to reset the program to its original state by pressing the ‘r’ key. This resets the size, shape, position and orientation of the object, and allows it to subsequently be manipulated again as before.

## What you should turn in

- all of your source code;
- a CMake file or readme in which you provide detailed instructions to the TA on how to compile and run your program;
- a brief video (preferred) or set of screen shots that provides evidence of the operational capabilities of your code
